---
title: 项目问答
date: 2001-03-01
tags:
  - 面试秘籍
categories:
  - 面试秘籍
---

<LockedPage>

# 项目问答
## 个人简介

面试官您好，我叫黄诚，来自湖北，现为中国地质大学计算机学院硕士二年级学生，主修专业是计算机技术，本科专业是计算机科学与技术；从大学以来，我一共参与了三个 Java 项目的开发工作，这里我就按照时间顺序简单说一下吧。

在大二期间我就进入了本科老师的项目组，参与了第一个项目：**武汉亚洲心脏病医院数据收集系统** 的开发，这是一套为了亚心医院内部的信息化管理而开发的系统，项目后端采用了 Spring + MyBatis-Plus 框架。

研一下在实验室的安排下，我前往北京参与了和中石化合作的项目：**钻井数据处理与展示平台** 的开发，该项目主要是针对企业导入的各种钻井数据进行分析计算和可视化操作，在这个项目中涉及到较多的临时计算数据，所以这时候我开始接触 Redis，了解到了缓存的重要性。

当时武汉的数皮科技公司作为技术顾问，给了我们一些指导，于是第三个项目是我们与该公司合作，开发一套可以运行代码工程文件的 **在线 IDE 编程平台** ，也就是前段时间在推进的第三个项目。由于有了前两次的开发经验，所以在该项目中我担任实验室团队的组长，在承担开发工作的同时，还负责和甲方对接各项需求，做好技术选型，应对阶段性检查。

以上就是我学生期间所参与的项目。此外我本科期间结题一项省级大学生创新创业训练计划项目，研究生期间和实验室团队一起参加互联网+比赛获得了省级银奖。而在学生工作方面，我担任了两年的学生班长，所以具有较多的人员沟通经验，获得过不少认可。

这就是我的个人介绍，谢谢！

下面是我的项目介绍：

## 在线 IDE 编程平台

**在线 IDE 编程平台** 是我去年 9 月份开始参与的项目，该软件是和企业合作，主要是为了应对 **学校教学**、**企业笔试** 等场景而开发的一套在线编程系统。

一开始我们以为是要开发一个 OJ 判题系统，前端提交代码，后端运行代码后，将样例以文件的形式读入，并对输出进行比较就可以了。

但甲方的需求比我们想象的还要复杂，一个集成开发工具的功能比 OJ 要全面很多，比如支持多文件运行、支持多环境切换、支持代码交互等。

### 项目的难点

在这套系统的开发过程中，我遇到的挑战可以分为 **代码实现** 和 **项目管理** 这两种。

#### 在代码实现方面

首先是 **第一个难点**：**每个用户需要安全、互不干扰的代码运行环境，同时每个项目的初始配置需求不一样，这点该如何保证？**

一开始我们想到了利用虚拟机，为代码执行提供安全的隔离环境，同时维持每个项目的独立配置需求。但是虚拟机的启动速度非常慢，并且虚拟机的资源消耗实在是太高，一台机器上启动不了几台虚拟机就会非常卡顿。

有什么能代替虚拟机的功能但又非常轻量呢？我们想到了当时比较流行的 Docker，Docker 在资源效率、启动速度、可移植性上相比虚拟机有明显优势。我们完全可以让用户的工程代码执行在不同的 Docker 容器中，这样就可以得到一个代码运行的隔离沙箱，实现和虚拟机一样的安全性。

那每个工程项目需要的初始配置不一样，比如编程语言、插件版本等，这个该怎么办？

刚好 Docker 提供了镜像仓库的功能，那我们就让用户在工程创建时选择自己需要的编程语言、插件版本等参数，以此在后端生成独一无二的 Dockerfile。

再根据这个 Dockerfile 来生成镜像，我们就可以获得一个完全符合此配置需求的专属镜像。

这个问题的解决过程，让我知道了 **技术选型** 的重要性，虚拟机和 Docker 其实都可以实现我们需要的功能，但从实现成本、开发效率、操作难易程度上可以说是天壤之别。可以说，如果不是技术选型做的好，那我们需要走的弯路可能要多得多。

**第二个难点** 是：**用户需要和正在运行中的代码进程进行交互，比如实时输入和输出，这该怎么做到。而且在一个工程项目里想同时运行多个代码怎么办？**

在 OJ 判题系统中是没有这样的需求的，所以当时我们很困扰，在这种对实时性要求很高的情况下，使用 HTTP 请求的话，需要频繁建立连接，这对网络资源的消耗是巨大的。

首先想到的是 HTTP 在1.1版本之后的新功能：长链接，以此实现一次链接，多次通信。但长连接的每个请求和响应还是独立的，并未改变 HTTP 的单向通信模式。而在搜索 HTTP 长连接相关知识的时候，我们意外发现了 WebSocket 这种网络协议，它完美地提供了一个实时的全双工通信渠道，这使得用户与正在运行的代码进程之间的双向交互成为了可能。

那多文件的交互怎么办？如何将用户指令和特定进程绑定起来呢？当时我正在学习一些线程池的知识，因为要使用多线程来启动和管理外部进程。那么，既然线程可以有线程池，那我们能不能借鉴线程池的思想，在后端也维护一个 **进程池** 呢，不同之处在于，线程池管理的是线程，而我们要管理的是进程。

于是，我们利用线程安全的 ConcurrentHashMap 写了一个接口来统一管理进程，每次新建一个进程的时候，就在进程池中存储这个进程，同时给前端返回进程的句柄，这样前端在进行信息传输的时候，通过这个进程句柄就可以实现和对应的进程进行交互，而在程序终止的时候，后端就会销毁进程，并从进程池中移除该进程。

这个问题的解决，让我知道了 **知识迁移** 的重要性，通过对线程池知识的积累学习，才能让我想到模拟线程池，维护进程池的这个方案。事实上很多 Java 框架里面都用到了类似线程池的思想，比如 MyBatis 里面的数据库连接池，也和这个差不多。我觉得只要基础知识扎实，框架的迭代是不会淘汰人的，因为框架底层都是那一套，只是封装的效果有所不同。

#### 而在项目管理上的麻烦主要有两件事

一是：**甲方的需求不断变动，怎么节省人力资源，避免无用的工作**。

由于之前在和中石化的项目合作上吃过亏，所以这次我们采用了 **敏捷开发** 的思路，我们固定每周都要和甲方开一次会，以避免开发过程中出现需求和产出的不一致。

开会内容主要是和甲方核对上周的工作内容，同时讨论下周的任务需求。作为组长，我负责提炼出这些需求中最重要的20%，也就是最影响系统核心、最不易变动的20%，并让甲方在我们的需求文档上进行签字，之后每周我们就集中实现这部分功能，其余的功能则只做暂时记录。

**因为这些甲方往往是：你不把东西做出来给他看，他也不知道自己要的到底是什么。**

而通过我的做法，即使甲方的需求发生了变化，往往也不会影响太严重，方便我们及时调整方向，避免打击开发人员的积极性。

二是：**开发人员中间从研二换为了研一的，如何快速交接工作，避免进度的延后**。

首先是我们要求每个同学在写代码的时候都要加上方法级别的注释，方便其他人阅读我们的源码。

同时让研一的同学一开始先尝试重写一些简单的模块，让他们熟悉代码库和开发流程之后，再逐步增加难度，确保快速上手。

**事实上，在这个项目开发的过程中，我接触到了从需求谈判、到真正开发、到遇到难题、解决难题、再到软件说明书编写、到项目中期检查汇报的整个流程，真的可以说是很累很累，但也是收获满满。**

**最大的体会就是：对业务逻辑的把握和理解，甚至比开发技术更加重要。有时候不是代码有多不好写，而是需求没能理解到位，往往只要需求剖析到透彻了，想明白了，写代码就是最简单的事了。**

当然这个项目目前还有一些不足之处，比如：

### 项目的不足之处

- 前端每次更改文件后，会隔一段时间发送整个文件的内容给后端，这种做法在处理大文件时会导致性能问题，后续我们打算通过采用增量更新的策略来减少网络负载。

- 其次，我们还没来得及实现用户代码的版本控制功能，就像 git 那样。

  后续的想法是给文件分配一个版本号，然后一起存储在 FastDFS 里，同时，在数据库中记录每个文件的版本信息。

  这样，即使 FastDFS 本身不支持版本控制，我们也能通过数据库查询来管理文件的不同版本。

### 你在项目中学到了什么

感觉这个项目让自己对项目开发有了很深的认识，

- 在不断遇到问题时，要想不同的方案来解决问题，对软件开发效率，安全性以及可扩展性更加有考虑。
- 同时接触到了一些新技术，比如docker、fastDFS、WebSocket等。
- 而且作为项目负责人，我开始明白了合理分配工作、实时检查进度、及时解决问题的重要性。

我本身就特别喜欢这样的氛围，一群人为了做成一件事而一起努力，最后把它完成，中间很累，也有争吵和不理解，但是得到认可的那一刻，我还是觉得非常开心。

### 项目的架构

后端主要分为：

- Docker 管理模块：处理用户登录请求、工程初始化请求
- Docker 内的代码运行模块：负责运行代码、接收文件的增删改查请求
- fastDFS 文件存储模块：负责存储文件
- MySQL 数据库：存储信息
- Redis 数据库：缓存功能

### 数据库设计

核心有 5 张表：

**用户表**：

此表存储用户的基本信息。

```
- UserId (INT, PK): 用户的唯一标识。
- Username (VARCHAR): 用户名。
- Email (VARCHAR): 用户的电子邮件地址。
- PasswordHash (VARCHAR): 加密后的密码。
- CreatedAt (DATETIME): 账户创建时间。
- LastLogin (DATETIME): 最后登录时间。
```

**项目表**：

存储各个项目的元信息，以方便管理项目。

```
- ProjectId (INT, PK): 项目的唯一标识。
- Name (VARCHAR): 项目名称。
- Description (TEXT): 项目描述。
- OwnerId (INT, FK): 项目所有者的用户ID，关联到用户表。
- CreatedAt (DATETIME): 项目创建时间。
- UpdatedAt (DATETIME): 项目最后更新时间。
```

**项目配置表**：

这张表用来存储项目的基本配置信息，每条记录对应一个项目的特定配置。

```
- ConfigId (INT, PK): 配置的唯一标识符。
- ProjectId (INT, FK): 关联的项目ID。
- Language (VARCHAR): 编程语言，例如Python、C++、Java。
- LanguageVersion (VARCHAR): 语言版本，如Python 3.8、C++11、Java 8。
- CreatedAt (DATETIME): 配置创建时间。
- UpdatedAt (DATETIME): 配置最后更新时间。
```

**项目配置详情表**：

由于项目可能需要多个插件或工具，这张表用来存储每个项目配置的详细信息，比如插件名称和版本等。

```
- DetailId (INT, PK): 配置详情的唯一标识符。
- ConfigId (INT, FK): 关联的项目配置ID。
- Key (VARCHAR): 配置项的键，例如`Compiler`、`Plugin`等。
- Value (VARCHAR): 配置项的值，如特定的编译器名称或插件版本。
```

**文件表**（为了形成树形结构）：

这张表用来存储文件的元数据，每条记录与 FastDFS 中的一个文件对应。

```
- ItemId (INT, PK): 每个文件或目录的唯一标识符。
- ParentId (INT, NULLABLE): 父目录的ItemId。如果是根目录或顶级文件，则为NULL。
- ProjectId (INT, FK): 文件所属的项目ID。
- Name (VARCHAR): 文件或目录名。
- FastDFSId (VARCHAR, NULLABLE): 文件存储在FastDFS中的唯一标识符。对于目录，此字段可为空。
- Type (ENUM('file', 'directory')): 指示该项是文件还是目录。
- Size (BIGINT, NULLABLE): 文件大小，单位为字节。对于目录，此字段可为空。
- CreatedAt (DATETIME): 创建时间。
- UpdatedAt (DATETIME): 最后更新时间。
```

### 登录流程

- 用户登录时，**Docker 管理模块** 验证用户的凭证（如用户名和密码）。
- 验证成功后，**Docker 管理模块** 生成一个 Token，并将该 Token 存储在 Redis 中，方便进行 **单点登录** 和 **单设备登录**。
- **Docker 管理模块** 将 Token 返回给前端。
- 前端在随后的每次请求中携带这个 Token ，**Docker 管理模块** 通过验证请求中的 Token 和 Redis 中是否一致来确认用户身份和权限。

### 新建代码工程并添加文件

- 用户登录之后，开始新建代码工程项目，此时他可以选择代码语言、代码框架、编译器版本等配置，点击确认后，会将工程的配置信息发送到 **Docker 管理模块**。
- **Docker 管理模块** 将工程的配置信息存储到数据库中，为工程分配一个唯一的ID，以及保存用户选择的编程语言、框架、编译器版本等信息。
- 根据配置信息，**Docker 管理模块** 编写好 Dockerfile，并通过调用 Docker API 发送 Docker 容器初始化的指令。
- 这些指令包括构建镜像、启动容器、端口映射。
- Docker 容器初始化完毕后，容器内的 **代码运行模块** 会查询数据库，查询当前工程下的文件 id 以及文件夹结构，如果文件 id 不为空，则从 FastDFS 中拉取文件，按照文件夹结构来保存到容器内。
- **Docker 管理模块** 将 Docker 容器的 ip 和 **代码运行模块** 的端口发送给前端，之后前端针对此工程文件的请求，都将直接发送给 docker 容器内的 **代码运行模块**。
- 此时前端和代码运行模块建立起 WebSocket 连接，之后代码的增删改查操作、代码编译运行请求，都将直接由 **代码运行模块** 来处理，若 WebSocket 断开或者前端长期无请求，代表用户下线，此时 **代码运行模块** 保存好当前文件后，给 **Docker 管理模块** 发送容器销毁请求。

### 点开已有的代码工程

- 前端发送请求到 **Docker 管理模块**，请求包含工程的唯一 ID。
- **Docker 管理模块 **根据工程ID查询数据库，获取该工程的配置信息，包括编程语言、框架、编译器版本等。
- **Docker 管理模块** 将根据工程的配置信息，编写 Dockerfile 并通过调用 Docker API 来构建镜像、启动新的容器，并进行端口映射。
- 一旦容器准备就绪，容器内的**代码运行模块**将查询数据库，获取当前工程下的文件 ID 以及文件夹结构。
- 如果存在文件ID，则 **代码运行模块** 从 FastDFS 中拉取对应的文件，按照数据库中记录的文件夹结构保存到容器内。
- **Docker 管理模块** 将 Docker 容器的 IP 和 **代码运行模块** 监听的端口发送给前端。
- 前端根据这些信息建立 WebSocket 连接到 **代码运行模块**，之后的文件增删改查操作、代码编译运行请求等都通过这个 WebSocket 连接进行。
- 如果 WebSocket 连接断开或者前端长期无请求，代表用户可能已下线。此时，**代码运行模块 **会保存好当前的工程文件状态，会向 **Docker 管理模块 **发送容器销毁请求。


</LockedPage>