---
title: 236.二叉树的最近公共祖先
date: 2024-04-13
tags: 
 - 树
 - 深度优先搜索
 - 二叉树
 - 双向链表
categories:
 - 力扣每日一题
---

# 236.二叉树的最近公共祖先

**难度：中等**

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

**示例 1：**

![img](./assets/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](./assets/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内
- `-109 <= Node.val <= 109`
- 所有 `Node.val` 互不相同
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中

## 解题思路

若 root 是 p、q 的 **最近公共祖先**，则只可能为以下情况之一：

- p 和 q 分别在 root 的左右子树中
- root = p ，且 q 在 root 的左子树或右子树中
- root = q ，且 p 在 root 的左子树或右子树中

那么首先想的是：要是能自底向上查找就好了，这样就可以找到公共祖先了。

那么二叉树如何可以自底向上查找呢？答案是：回溯，二叉树回溯的过程就是从底到上。

后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。

考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。

从底至顶回溯，当节点 p、q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。

**递归过程**：

1. **终止条件**：
   - 当前节点为空，则返回 null
   - 当前节点等于 p 或 q ，则直接返回当前节点（以当前节点为根节点的子树不用再往下遍历了）
2. 递推工作：
   开启递归左子节点，返回值记为 leftleftleft ；
   开启递归右子节点，返回值记为 rightrightright ；
3. 返回值： 根据 leftleftleft 和 rightrightright ，可展开为四种情况；
   当 leftleftleft 和 rightrightright 同时为空 ：说明 rootrootroot 的左 / 右子树中都不包含 p,qp,qp,q ，返回 nullnullnull ；
   当 leftleftleft 和 rightrightright 同时不为空 ：说明 p,qp, qp,q 分列在 rootrootroot 的 异侧 （分别在 左 / 右子树），因此 rootrootroot 为最近公共祖先，返回 rootrootroot ；
   当 leftleftleft 为空 ，rightrightright 不为空 ：p,qp,qp,q 都不在 rootrootroot 的左子树中，直接返回 rightrightright 。具体可分为两种情况：
   p,qp,qp,q 其中一个在 rootrootroot 的 右子树 中，此时 rightrightright 指向 ppp（假设为 ppp ）；
   p,qp,qp,q 两节点都在 rootrootroot 的 右子树 中，此时的 rightrightright 指向 最近公共祖先节点 ；
   当 leftleftleft 不为空 ， rightrightright 为空 ：与情况 3. 同理；

